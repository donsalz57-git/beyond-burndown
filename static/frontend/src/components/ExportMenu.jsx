import React, { useState } from 'react';

/**
 * ExportMenu - Export dropdown for generating reports
 */
function ExportMenu({ data }) {
  const [isOpen, setIsOpen] = useState(false);
  const [copied, setCopied] = useState(false);

  if (!data) return null;

  const generateTextReport = () => {
    const { envelope, compliance, dependencies, statusReport } = data;

    const lines = [
      '='.repeat(60),
      'PROJECT STATUS REPORT',
      `Generated: ${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}`,
      '='.repeat(60),
      '',
      'HEADLINE METRICS',
      '-'.repeat(30),
      `Feasibility Score: ${envelope?.feasibilityScore || 0}%`,
      `Forecast: ${envelope?.forecast?.message || 'On track'}`,
      `Capacity Utilization: ${statusReport?.headline?.capacityUtilization?.percent || 0}%`,
      `Completion: ${statusReport?.headline?.completion?.percent || 0}%`,
      '',
      'SCHEDULE',
      '-'.repeat(30),
      `Deadline: ${formatDate(statusReport?.schedule?.deadline)}`,
      `Forecast: ${formatDate(statusReport?.schedule?.forecast)}`,
      `Status: ${statusReport?.schedule?.bufferLabel || 'On time'}`,
      '',
      'CAPACITY',
      '-'.repeat(30),
      `Available: ${envelope?.totals?.totalCapacity?.toFixed(1) || 0}h`,
      `Demand: ${envelope?.totals?.totalDemand?.toFixed(1) || 0}h`,
      `Time Spent: ${envelope?.totals?.totalTimeSpent?.toFixed(1) || 0}h`,
      `Gap: ${((envelope?.totals?.totalDemand || 0) - (envelope?.totals?.totalCapacity || 0)).toFixed(1)}h`,
      '',
      'PROGRESS',
      '-'.repeat(30),
      `Closed: ${statusReport?.progress?.closedCount || 0} issues (${statusReport?.progress?.closedHours || 0}h)`,
      `Remaining: ${statusReport?.progress?.remainingCount || 0} issues (${statusReport?.progress?.remainingHours || 0}h)`,
      '',
      'RISKS',
      '-'.repeat(30),
      `Overloaded Periods: ${envelope?.overloadedPeriods?.length || 0}`,
      `Compliance Violations: ${compliance?.summary?.total || 0}`,
      `Circular Dependencies: ${dependencies?.circularDependencies?.length || 0}`,
      `Overdue Issues: ${statusReport?.risks?.overdueIssues?.count || 0}`,
      '',
      'DATA CONFIDENCE',
      '-'.repeat(30),
      `Score: ${envelope?.confidence?.overallScore || 0}% (${envelope?.confidence?.level || 'unknown'})`,
      `Estimates: ${envelope?.confidence?.breakdown?.estimates?.percent || 0}% complete`,
      `Dates: ${envelope?.confidence?.breakdown?.dates?.percent || 0}% complete`,
      `Assignees: ${envelope?.confidence?.breakdown?.assignees?.percent || 0}% assigned`,
    ];

    // Add decisions if any
    if (statusReport?.decisions?.length > 0) {
      lines.push('');
      lines.push('DECISIONS NEEDED');
      lines.push('-'.repeat(30));
      statusReport.decisions.forEach((d, i) => {
        lines.push(`${i + 1}. [${d.priority.toUpperCase()}] ${d.title}`);
        lines.push(`   ${d.description}`);
        if (d.options) {
          lines.push(`   Options: ${d.options.join(' | ')}`);
        }
      });
    }

    // Add team health summary
    if (envelope?.resources?.length > 0) {
      lines.push('');
      lines.push('TEAM HEALTH');
      lines.push('-'.repeat(30));
      envelope.resources.forEach(r => {
        const load = r.loadPercent !== null ? `${r.loadPercent}%` : 'N/A';
        lines.push(`${r.assignee}: ${r.demand}h demand, ${load} load, ${r.status}`);
      });
    }

    lines.push('');
    lines.push('='.repeat(60));
    lines.push('Generated by Beyond Burndown');

    return lines.join('\n');
  };

  const generateMarkdownReport = () => {
    const { envelope, compliance, dependencies, statusReport } = data;

    const lines = [
      '# Project Status Report',
      `*Generated: ${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}*`,
      '',
      '## Headline Metrics',
      '',
      '| Metric | Value |',
      '|--------|-------|',
      `| Feasibility Score | **${envelope?.feasibilityScore || 0}%** |`,
      `| Forecast | ${envelope?.forecast?.message || 'On track'} |`,
      `| Capacity Utilization | ${statusReport?.headline?.capacityUtilization?.percent || 0}% |`,
      `| Completion | ${statusReport?.headline?.completion?.percent || 0}% |`,
      '',
      '## Schedule',
      '',
      `- **Deadline:** ${formatDate(statusReport?.schedule?.deadline)}`,
      `- **Forecast:** ${formatDate(statusReport?.schedule?.forecast)}`,
      `- **Status:** ${statusReport?.schedule?.bufferLabel || 'On time'}`,
      '',
      '## Capacity',
      '',
      `- Available: ${envelope?.totals?.totalCapacity?.toFixed(1) || 0}h`,
      `- Demand: ${envelope?.totals?.totalDemand?.toFixed(1) || 0}h`,
      `- Time Spent: ${envelope?.totals?.totalTimeSpent?.toFixed(1) || 0}h`,
      `- Gap: ${((envelope?.totals?.totalDemand || 0) - (envelope?.totals?.totalCapacity || 0)).toFixed(1)}h`,
      '',
      '## Risks',
      '',
      `- Overloaded Periods: **${envelope?.overloadedPeriods?.length || 0}**`,
      `- Compliance Violations: **${compliance?.summary?.total || 0}**`,
      `- Circular Dependencies: **${dependencies?.circularDependencies?.length || 0}**`,
      `- Overdue Issues: **${statusReport?.risks?.overdueIssues?.count || 0}**`,
      '',
    ];

    if (statusReport?.decisions?.length > 0) {
      lines.push('## Decisions Needed');
      lines.push('');
      statusReport.decisions.forEach(d => {
        lines.push(`### ${d.title}`);
        lines.push(`*Priority: ${d.priority}*`);
        lines.push('');
        lines.push(d.description);
        if (d.options) {
          lines.push('');
          lines.push(`**Options:** ${d.options.join(' | ')}`);
        }
        lines.push('');
      });
    }

    lines.push('---');
    lines.push('*Generated by Beyond Burndown*');

    return lines.join('\n');
  };

  const formatDate = (dateStr) => {
    if (!dateStr) return 'N/A';
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  };

  const copyToClipboard = (format) => {
    const text = format === 'markdown' ? generateMarkdownReport() : generateTextReport();
    navigator.clipboard.writeText(text).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    });
    setIsOpen(false);
  };

  const downloadTextFile = () => {
    const text = generateTextReport();
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `status-report-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    setIsOpen(false);
  };

  return (
    <div className="export-menu">
      <button
        onClick={() => setIsOpen(!isOpen)}
        style={{
          padding: '6px 12px',
          background: '#F4F5F7',
          color: '#172B4D',
          border: 'none',
          borderRadius: '4px',
          fontSize: '12px',
          cursor: 'pointer',
          fontWeight: 500,
          display: 'flex',
          alignItems: 'center',
          gap: '4px'
        }}
      >
        {copied ? 'Copied!' : 'Export'}
        <span style={{ fontSize: '10px' }}>â–¼</span>
      </button>

      {isOpen && (
        <div className="export-dropdown">
          <button onClick={() => copyToClipboard('text')}>
            Copy as Text
          </button>
          <button onClick={() => copyToClipboard('markdown')}>
            Copy as Markdown
          </button>
          <button onClick={downloadTextFile}>
            Download .txt
          </button>
        </div>
      )}
    </div>
  );
}

export default ExportMenu;
